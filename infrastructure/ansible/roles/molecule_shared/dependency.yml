---
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

- hosts: localhost
  connection: local
  gather_facts: false

  vars:
    secret_varfile_src: "{{ playbook_dir }}/secret_varfile.json"
    secret_varfile_dest: "{{ lookup('env','MOLECULE_EPHEMERAL_DIRECTORY') }}/secret_varfile.json"
    lab_ssl_dir: "{{ playbook_dir }}/files/ssl"
    lab_deb_dir: "{{ lookup('env','MOLECULE_EPHEMERAL_DIRECTORY') }}//files/deb/{{ ubuntu_version }}"
    lab_sdeb_dir: "{{ lookup('env','MOLECULE_EPHEMERAL_DIRECTORY') }}//files/sdeb/{{ ubuntu_version }}"
    lab_ca_root_csr: "{{ lab_ssl_dir }}/lab.rootca.key.csr"
    lab_ca_root_key: "{{ lab_ssl_dir }}/lab.rootca.key.pem"
    lab_ca_root_crt: "{{ lab_ssl_dir }}/lab.rootca.crt"
    lab_ca_int_csr: "{{ lab_ssl_dir }}/lab.intermediateca.csr"
    lab_ca_int_key: "{{ lab_ssl_dir }}/lab.intermediateca.key.pem"
    lab_ca_int_crt: "{{ lab_ssl_dir }}/lab.intermediateca.crt"
    deb_dist_dir: "{{ playbook_dir }}/../../../../dist"
    ubuntu_version: "{{ matrix_distro_mapping[lookup('env','MOLECULE_DISTRO') | default('ubuntu7',true)] }}"
    extended_ubuntu_version: "el{{ ubuntu_version }}"
    matrix_distro_mapping:
      ubuntu7: 7
      ubuntu8: 8

  tasks:
    - name: Load existing secret varfile
      include_vars:
        file: "{{ secret_varfile_src }}"
        name: existing_secrets
      ignore_errors: true
      no_log: true

    - name: Load scenario requirements varfile
      include_vars:
        file: "{{ lookup('first_found', possible_files) }}"
        name: scenario_requirements
      vars:
        possible_files:
          - "{{ lookup('env','MOLECULE_SCENARIO_DIRECTORY') }}/scenario.requirement.vars.yml"
          - "{{ lookup('env','MOLECULE_SCENARIO_DIRECTORY') }}/../scenario.requirement.vars.yml"
      no_log: true

    - name: Populate all the secrets to be used with this lab
      set_fact:
        secrets:
          postgresql_admin_user_password: "{{ existing_secrets_nullable.postgresql_admin_user_password | default(lookup('password', password_settings)) }}"
          postgresql_replica_user_password: "{{ existing_secrets_nullable.postgresql_replica_user_password | default(lookup('password', password_settings)) }}"
          todb_password: "{{ existing_secrets_nullable.todb_password | default(lookup('password', password_settings)) }}"
          tvdb_password: "{{ existing_secrets_nullable.tvdb_password | default(lookup('password', password_settings)) }}"
      no_log: true
      vars:
        existing_secrets_nullable: (existing_secrets | default({}))
        password_settings: /dev/null chars=ascii_letters,digits length=16

    - name: Write out the completed secret file (including backfilling new ones)
      copy:
        content: "{{ secrets | to_nice_json(indent=2) }}"
        dest: "{{ item }}"
        mode: '0600'
      with_items:
        - "{{ secret_varfile_src }}"
        - "{{ secret_varfile_dest }}"

    - name: Check if SSL data already exists
      stat:
        path: "{{ lab_ca_root_csr }}"
      register: ssl_data

    - name: Generate SSL data
      block:
        - name: Ensure SSL info directory exists
          file:
            state: directory
            path: "{{ lab_ssl_dir }}"

        - name: Regenerate Lab Root CA Private key
          openssl_privatekey:
            path: "{{ lab_ca_root_key }}"
            force: yes

        - name: Regenerate Lab Root CA CSR
          openssl_csr:
            basic_constraints:
              - CA:TRUE
            privatekey_path: "{{ lab_ca_root_key }}"
            subject:
              CN: CDNLAB.invalid
              C: US
              ST: Colorado
              L: Denver
              O: Molecule Testing
              OU: CDN
              emailAddress: ops@email.invalid
            path: "{{ lab_ca_root_csr }}"
            force: yes

        - name: Regenerate Lab Root CA Certificate
          openssl_certificate:
            csr_path: "{{ lab_ca_root_csr }}"
            force: yes
            path: "{{ lab_ca_root_crt }}"
            privatekey_path: "{{ lab_ca_root_key }}"
            provider: selfsigned

        - name: Generate Intermediate Signing CA Private keys
          openssl_privatekey:
            path: "{{ lab_ca_int_key }}"
            force: yes

        - name: Generate Intermediate Signing CA CSRs
          openssl_csr:
            privatekey_path: "{{ lab_ca_int_key }}"
            subject:
              CN: "Lab Intermediate CA"
              C: US
              ST: Colorado
              L: Denver
              O: Molecule Testing
              OU: CDN
              emailAddress: ops@email.invalid
            key_usage:
              - digitalSignature
              - keyCertSign
            basic_constraints:
              - CA:TRUE
              - pathlen:0
            path: "{{ lab_ca_int_csr }}"
            force: yes

        - name: Generate Intermediate Signing CA Certificates
          openssl_certificate:
            csr_path: "{{ lab_ca_int_csr }}"
            force: yes
            path: "{{ lab_ca_int_crt }}"
            privatekey_path: "{{ lab_ca_int_key }}"
            provider: ownca
            ownca_path: "{{ lab_ca_root_crt }}"
            ownca_privatekey_path: "{{ lab_ca_root_key }}"
      when: not ssl_data.stat.exists

    - name: Make SSL data available to molecule instances
      copy:
        src: "{{ lab_ssl_dir }}/"
        dest: "{{ lookup('env','MOLECULE_EPHEMERAL_DIRECTORY') }}/files/ssl/"

    - name: Prepare the DEBs for the upcoming instances
      block:
        - name: Check if needed DEBs exist
          shell: "ls -l {{ deb_dist_dir }}/*.deb | grep -vE 'debuginfo|debugsource|\\.src\\.deb' | tr -s ' ' ' ' | cut -d' ' -f9 | grep el{{ ubuntu_version }} | grep -E '{{ scenario_requirements.required_debs | map(attribute='deb_prefix') | join('|') | default('NONE', true) }}'"
          register: pkg_debs
          ignore_errors: true
          changed_when: false
          failed_when: false

        - name: Get pkg targets that require the optional flag
          command: "./pkg -{{ ubuntu_version }} -o -l"
          args:
            chdir: "{{ playbook_dir }}/../../../.."
          register: optional_pkg_targets
          changed_when: false

        - name: Find missing non-optional debs
          set_fact:
            missing_non_optional_debs: "{{ (missing_non_optional_debs | default([])) + [item.pkg_script_name] }}"
          with_items: "{{ filtered_req_debs }}"
          when: (matched_debs | length) == 0
          vars:
            build_targets: "{{ scenario_requirements.required_debs | map(attribute='pkg_script_name') | difference(optional_pkg_targets.stdout_lines) }}"
            filtered_req_debs_query_dynamic: "{% for p in build_targets %}pkg_script_name == `{{ p }}`{% if not loop.last %} || {% endif %}{% endfor %}"
            filtered_req_debs_query: "[?{{ filtered_req_debs_query_dynamic if filtered_req_debs_query_dynamic != '' else false }}]"
            filtered_req_debs: "{{ scenario_requirements.required_debs | json_query(filtered_req_debs_query) }}"
            matched_debs_query: "[?starts_with(@,`{{ item.deb_prefix }}`)]"
            matched_debs: "{{ pkg_debs.stdout_lines | map('basename') | json_query(matched_debs_query) }}"

        - name: Find missing optional debs
          set_fact:
            missing_optional_debs: "{{ (missing_optional_debs | default([])) + [item.pkg_script_name] }}"
          with_items: "{{ filtered_req_debs }}"
          when: (matched_debs | length) == 0
          vars:
            build_targets: "{{ scenario_requirements.required_debs | map(attribute='pkg_script_name') | intersect(optional_pkg_targets.stdout_lines) }}"
            filtered_req_debs_query_dynamic: "{% for p in build_targets %}pkg_script_name == `{{ p }}`{% if not loop.last %} || {% endif %}{% endfor %}"
            filtered_req_debs_query: "[?{{ filtered_req_debs_query_dynamic if filtered_req_debs_query_dynamic != '' else false }}]"
            filtered_req_debs: "{{ scenario_requirements.required_debs | json_query(filtered_req_debs_query) }}"
            matched_debs_query: "[?starts_with(@,`{{ item.deb_prefix }}`)]"
            matched_debs: "{{ pkg_debs.stdout_lines | map('basename') | json_query(matched_debs_query) }}"

        - name: Invoke pkg to build missing debs
          command: "{{ item.cmdstr }}"
          args:
            chdir: "{{ playbook_dir }}/../../../.."
          when: (item.target_debs | length) > 0
          with_items:
            - cmdstr: "./pkg -v -{{ ubuntu_version }} {{ missing_non_optional_debs | default([]) | join(' ') }}"
              target_debs: "{{ missing_non_optional_debs | default([]) }}"
            - cmdstr: "./pkg -v -{{ ubuntu_version }} -o {{ missing_optional_debs | default([]) | join(' ') }}"
              target_debs: "{{ missing_optional_debs | default([]) }}"

        - name: Ensure DEB directories exists
          file:
            state: directory
            path: "{{ item }}"
          with_items:
            - "{{ lab_deb_dir }}"
            - "{{ lab_sdeb_dir }}"
            - "{{ playbook_dir }}/../../../../dist/"

        - name: Copy in the DEBs
          copy:
            src: "{{ item.0 }}"
            dest: "{{ item.1 }}"
          vars:
            host_deb_path: "{{ playbook_dir }}/../../../../dist/"
            host_deb_glob: "{{ host_deb_path }}*{{ extended_ubuntu_version }}*x86_64.deb"
            host_sdeb_glob: "{{ host_deb_path }}*{{ extended_ubuntu_version }}*src.deb"
            deb_dest: "{{ lab_deb_dir }}"
            sdeb_dest: "{{ lab_sdeb_dir }}"
            deb_name: "{{ item.0 | basename }}"
            all_debname_regex: "{{ scenario_requirements.required_debs | map(attribute='deb_prefix') | map('regex_replace','^(.*)$','^\\1.*$') | join('|') }}"
          when: deb_name is search(all_debname_regex) and all_debname_regex != ""
          with_items:
            - "{{ (lookup('fileglob',host_deb_glob) | default('',true)).split(',') | product([deb_dest]) }}"
            - "{{ (lookup('fileglob',host_sdeb_glob) | default('',true)).split(',') | product([sdeb_dest]) }}"
